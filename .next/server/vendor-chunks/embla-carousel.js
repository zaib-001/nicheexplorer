"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel";
exports.ids = ["vendor-chunks/embla-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n    const documentVisibleHandler = EventStore();\n    const timeStep = 1000 / 60;\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function init() {\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) reset();\n        });\n    }\n    function destroy() {\n        stop();\n        documentVisibleHandler.clear();\n    }\n    function animate(timeStamp) {\n        if (!animationFrame) return;\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            update();\n            lag -= timeStep;\n        }\n        const lagOffset = mathAbs(lag / timeStep);\n        render(lagOffset);\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start() {\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop() {\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        init,\n        destroy,\n        start,\n        stop,\n        update,\n        render\n    };\n    return self;\n}\nfunction Axis(axis, contentDirection) {\n    const isRightToLeft = contentDirection === \"rtl\";\n    const isVertical = axis === \"y\";\n    const scroll = isVertical ? \"y\" : \"x\";\n    const cross = isVertical ? \"x\" : \"y\";\n    const sign = !isVertical && isRightToLeft ? -1 : 1;\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { height, width } = nodeRect;\n        return isVertical ? height : width;\n    }\n    function getStartEdge() {\n        if (isVertical) return \"top\";\n        return isRightToLeft ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (isVertical) return \"bottom\";\n        return isRightToLeft ? \"left\" : \"right\";\n    }\n    function direction(n) {\n        return n * sign;\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize,\n        direction\n    };\n    return self;\n}\nfunction Limit(min = 0, max = 0) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis, direction } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const isTouchEvt = !isMouseEvent(evt, ownerWindow);\n        if (isTouchEvt && evt.touches.length >= 2) return up(evt);\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(0.75);\n        animation.start();\n        target.add(direction(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n            preventClick = false;\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        destroy,\n        pointerDown\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    ownerWindow.requestAnimationFrame(()=>{\n                        emblaApi.reInit();\n                        eventHandler.emit(\"resize\");\n                    });\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (destroyed) return;\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        const observeNodes = [\n            container\n        ].concat(slides);\n        observeNodes.forEach((node)=>resizeObserver.observe(node));\n    }\n    function destroy() {\n        if (resizeObserver) resizeObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, target, baseDuration, baseFriction) {\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            bodyVelocity += diff / scrollDuration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(offsetLocation.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(offsetLocation.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - offsetLocation.get());\n        const diffToTarget = target.get() - offsetLocation.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function usePixelTolerance(bound, snap) {\n        return deltaAbs(bound, snap) < 1;\n    }\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const { min, max } = scrollBounds;\n            const snap = scrollBounds.constrain(snapAligned);\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return max;\n            if (isLast) return min;\n            if (usePixelTolerance(min, snap)) return min;\n            if (usePixelTolerance(max, snap)) return max;\n            return snap;\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, offsetLocation, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(offsetLocation.get());\n        if (direction === -1) return reachedMin(offsetLocation.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((snap, index)=>({\n                diff: shortcut(snap - distance, 0),\n                index\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return target;\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) {\n            if (scrollBody.duration()) {\n                animation.start();\n            } else {\n                animation.update();\n                animation.render(1);\n                animation.update();\n            }\n        }\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler) {\n    let lastTabPressTime = 0;\n    function init() {\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach(addSlideFocusEvent);\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    function addSlideFocusEvent(slide) {\n        const focus = ()=>{\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            root.scrollLeft = 0;\n            const index = slides.indexOf(slide);\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n            eventHandler.emit(\"slideFocus\");\n        };\n        eventStore.add(slide, \"focus\", focus, {\n            passive: true,\n            capture: true\n        });\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(axis.direction(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, slides[index]),\n                target: ()=>offsetLocation.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge, direction } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB, index)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction(startGap) : 0;\n            const gapB = !loop && isLast ? direction(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n    // Options\n    const { align, axis: scrollAxis, direction, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const axis = Axis(scrollAxis, direction);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } })=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, options: { loop } }, lagOffset)=>{\n        const velocity = scrollBody.velocity();\n        const hasSettled = scrollBody.settled();\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        offsetLocation.set(location.get() - velocity + velocity * lagOffset);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = Animations(ownerDocument, ownerWindow, ()=>update(engine), (lagOffset)=>render(engine, lagOffset));\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, container)\n    };\n    return engine;\n}\nfunction EventHandler() {\n    let listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    function clear() {\n        listeners = {};\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on,\n        clear\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const eventHandler = EventHandler();\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.animation.init();\n        engine.slidesInView.init();\n        engine.slideFocus.init();\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        engine.animation.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n        eventHandler.clear();\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsU0FBU0MsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNFLFVBQVVGLE9BQU87SUFDeEIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0csU0FBU0gsT0FBTztJQUN2QixPQUFPSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxhQUFhO0FBQ3JEO0FBQ0EsU0FBU1EsUUFBUUMsQ0FBQztJQUNoQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGO0FBQ2xCO0FBQ0EsU0FBU0csU0FBU0gsQ0FBQztJQUNqQixPQUFPQyxLQUFLRyxJQUFJLENBQUNKO0FBQ25CO0FBQ0EsU0FBU0ssU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLE9BQU9SLFFBQVFPLFNBQVNDO0FBQzFCO0FBQ0EsU0FBU0MsVUFBVUYsTUFBTSxFQUFFQyxNQUFNO0lBQy9CLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHLE9BQU87SUFDekMsSUFBSVIsUUFBUU8sV0FBV1AsUUFBUVEsU0FBUyxPQUFPO0lBQy9DLE1BQU1FLE9BQU9KLFNBQVNOLFFBQVFPLFNBQVNQLFFBQVFRO0lBQy9DLE9BQU9SLFFBQVFVLE9BQU9IO0FBQ3hCO0FBQ0EsU0FBU0ksVUFBVUMsS0FBSztJQUN0QixPQUFPQyxXQUFXRCxPQUFPRSxHQUFHLENBQUNDO0FBQy9CO0FBQ0EsU0FBU0MsVUFBVUosS0FBSztJQUN0QixPQUFPQSxLQUFLLENBQUNLLGVBQWVMLE9BQU87QUFDckM7QUFDQSxTQUFTSyxlQUFlTCxLQUFLO0lBQzNCLE9BQU9WLEtBQUtnQixHQUFHLENBQUMsR0FBR04sTUFBTU8sTUFBTSxHQUFHO0FBQ3BDO0FB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UUFDUCxPQUFPaEUsT0FBT3JjLEtBQUssQ0FBQ2lHLEdBQUc7SUFDekI7SUFDQSxTQUFTNGE7UUFDUCxPQUFPeEUsT0FBT3JILGFBQWEsQ0FBQy9PLEdBQUc7SUFDakM7SUFDQSxTQUFTdVc7UUFDUCxPQUFPSCxPQUFPRyxZQUFZLENBQUN2VyxHQUFHO0lBQ2hDO0lBQ0EsU0FBUzZhO1FBQ1AsT0FBT3pFLE9BQU9HLFlBQVksQ0FBQ3ZXLEdBQUcsQ0FBQztJQUNqQztJQUNBLFNBQVNzWTtRQUNQLE9BQU9jO0lBQ1Q7SUFDQSxTQUFTMEI7UUFDUCxPQUFPMUU7SUFDVDtJQUNBLFNBQVNoVztRQUNQLE9BQU9nUDtJQUNUO0lBQ0EsU0FBUzJMO1FBQ1AsT0FBT3JVO0lBQ1Q7SUFDQSxTQUFTc1U7UUFDUCxPQUFPclU7SUFDVDtJQUNBLE1BQU05SyxPQUFPO1FBQ1g2ZTtRQUNBQztRQUNBSTtRQUNBRDtRQUNBbmQ7UUFDQXVaO1FBQ0FGO1FBQ0E5UztRQUNBb1U7UUFDQXNDO1FBQ0FoVDtRQUNBeEg7UUFDQW1hO1FBQ0FDO1FBQ0FsRTtRQUNBSTtRQUNBalc7UUFDQTJaO1FBQ0FZO1FBQ0F6RTtRQUNBc0U7SUFDRjtJQUNBZCxTQUFTcEIsYUFBYUM7SUFDdEJxQyxXQUFXLElBQU1yYSxhQUFhc0QsSUFBSSxDQUFDLFNBQVM7SUFDNUMsT0FBT3JJO0FBQ1Q7QUFDQTZjLGNBQWNRLGFBQWEsR0FBR3pXO0FBRU0sQ0FDcEMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmljaGVleHBsb3Jlci8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC9lc20vZW1ibGEtY2Fyb3VzZWwuZXNtLmpzPzJkODAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNOdW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gbWF0aEFicyhuKSB7XG4gIHJldHVybiBNYXRoLmFicyhuKTtcbn1cbmZ1bmN0aW9uIG1hdGhTaWduKG4pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihuKTtcbn1cbmZ1bmN0aW9uIGRlbHRhQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIHJldHVybiBtYXRoQWJzKHZhbHVlQiAtIHZhbHVlQSk7XG59XG5mdW5jdGlvbiBmYWN0b3JBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgaWYgKHZhbHVlQiA9PT0gMCB8fCB2YWx1ZUEgPT09IDApIHJldHVybiAwO1xuICBpZiAobWF0aEFicyh2YWx1ZUIpIDw9IG1hdGhBYnModmFsdWVBKSkgcmV0dXJuIDA7XG4gIGNvbnN0IGRpZmYgPSBkZWx0YUFicyhtYXRoQWJzKHZhbHVlQiksIG1hdGhBYnModmFsdWVBKSk7XG4gIHJldHVybiBtYXRoQWJzKGRpZmYgLyB2YWx1ZUIpO1xufVxuZnVuY3Rpb24gYXJyYXlLZXlzKGFycmF5KSB7XG4gIHJldHVybiBvYmplY3RLZXlzKGFycmF5KS5tYXAoTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdChhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXlMYXN0SW5kZXgoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdEluZGV4KGFycmF5KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNMYXN0SW5kZXgoYXJyYXksIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tTnVtYmVyKG4sIHN0YXJ0QXQgPSAwKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KG4pLCAoXywgaSkgPT4gc3RhcnRBdCArIGkpO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5mdW5jdGlvbiBvYmplY3RzTWVyZ2VEZWVwKG9iamVjdEEsIG9iamVjdEIpIHtcbiAgcmV0dXJuIFtvYmplY3RBLCBvYmplY3RCXS5yZWR1Y2UoKG1lcmdlZE9iamVjdHMsIGN1cnJlbnRPYmplY3QpID0+IHtcbiAgICBvYmplY3RLZXlzKGN1cnJlbnRPYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlQSA9IG1lcmdlZE9iamVjdHNba2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlQiA9IGN1cnJlbnRPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IGFyZU9iamVjdHMgPSBpc09iamVjdCh2YWx1ZUEpICYmIGlzT2JqZWN0KHZhbHVlQik7XG4gICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBhcmVPYmplY3RzID8gb2JqZWN0c01lcmdlRGVlcCh2YWx1ZUEsIHZhbHVlQikgOiB2YWx1ZUI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSB7XG4gIHJldHVybiB0eXBlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudDtcbn1cblxuZnVuY3Rpb24gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSkge1xuICBjb25zdCBwcmVkZWZpbmVkID0ge1xuICAgIHN0YXJ0LFxuICAgIGNlbnRlcixcbiAgICBlbmRcbiAgfTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gY2VudGVyKG4pIHtcbiAgICByZXR1cm4gZW5kKG4pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBlbmQobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAtIG47XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZShuLCBpbmRleCkge1xuICAgIGlmIChpc1N0cmluZyhhbGlnbikpIHJldHVybiBwcmVkZWZpbmVkW2FsaWduXShuKTtcbiAgICByZXR1cm4gYWxpZ24odmlld1NpemUsIG4sIGluZGV4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U3RvcmUoKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkKG5vZGUsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KSB7XG4gICAgbGV0IHJlbW92ZUxpc3RlbmVyO1xuICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gbm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZ2FjeU1lZGlhUXVlcnlMaXN0ID0gbm9kZTtcbiAgICAgIGxlZ2FjeU1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiBsZWdhY3lNZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gocmVtb3ZlTGlzdGVuZXIpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIocmVtb3ZlID0+IHJlbW92ZSgpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGFkZCxcbiAgICBjbGVhclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9ucyhvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdXBkYXRlLCByZW5kZXIpIHtcbiAgY29uc3QgZG9jdW1lbnRWaXNpYmxlSGFuZGxlciA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgdGltZVN0ZXAgPSAxMDAwIC8gNjA7XG4gIGxldCBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgbGV0IGxhZyA9IDA7XG4gIGxldCBhbmltYXRpb25GcmFtZSA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5hZGQob3duZXJEb2N1bWVudCwgJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAob3duZXJEb2N1bWVudC5oaWRkZW4pIHJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnRWaXNpYmxlSGFuZGxlci5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFuaW1hdGUodGltZVN0YW1wKSB7XG4gICAgaWYgKCFhbmltYXRpb25GcmFtZSkgcmV0dXJuO1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcDtcbiAgICBsYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgIGxhZyArPSBlbGFwc2VkO1xuICAgIHdoaWxlIChsYWcgPj0gdGltZVN0ZXApIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgbGFnIC09IHRpbWVTdGVwO1xuICAgIH1cbiAgICBjb25zdCBsYWdPZmZzZXQgPSBtYXRoQWJzKGxhZyAvIHRpbWVTdGVwKTtcbiAgICByZW5kZXIobGFnT2Zmc2V0KTtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHJldHVybjtcbiAgICBhbmltYXRpb25GcmFtZSA9IG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIG93bmVyV2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBsYWcgPSAwO1xuICAgIGFuaW1hdGlvbkZyYW1lID0gMDtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBsYWcgPSAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95LFxuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgdXBkYXRlLFxuICAgIHJlbmRlclxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQXhpcyhheGlzLCBjb250ZW50RGlyZWN0aW9uKSB7XG4gIGNvbnN0IGlzUmlnaHRUb0xlZnQgPSBjb250ZW50RGlyZWN0aW9uID09PSAncnRsJztcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGF4aXMgPT09ICd5JztcbiAgY29uc3Qgc2Nyb2xsID0gaXNWZXJ0aWNhbCA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBpc1ZlcnRpY2FsID8gJ3gnIDogJ3knO1xuICBjb25zdCBzaWduID0gIWlzVmVydGljYWwgJiYgaXNSaWdodFRvTGVmdCA/IC0xIDogMTtcbiAgY29uc3Qgc3RhcnRFZGdlID0gZ2V0U3RhcnRFZGdlKCk7XG4gIGNvbnN0IGVuZEVkZ2UgPSBnZXRFbmRFZGdlKCk7XG4gIGZ1bmN0aW9uIG1lYXN1cmVTaXplKG5vZGVSZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gbm9kZVJlY3Q7XG4gICAgcmV0dXJuIGlzVmVydGljYWwgPyBoZWlnaHQgOiB3aWR0aDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGFydEVkZ2UoKSB7XG4gICAgaWYgKGlzVmVydGljYWwpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gaXNSaWdodFRvTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoaXNWZXJ0aWNhbCkgcmV0dXJuICdib3R0b20nO1xuICAgIHJldHVybiBpc1JpZ2h0VG9MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBmdW5jdGlvbiBkaXJlY3Rpb24obikge1xuICAgIHJldHVybiBuICogc2lnbjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNjcm9sbCxcbiAgICBjcm9zcyxcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZSxcbiAgICBtZWFzdXJlU2l6ZSxcbiAgICBkaXJlY3Rpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiA9IDAsIG1heCA9IDApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWF0aEFicyhtaW4gLSBtYXgpO1xuICBmdW5jdGlvbiByZWFjaGVkTWluKG4pIHtcbiAgICByZXR1cm4gbiA8IG1pbjtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkTWF4KG4pIHtcbiAgICByZXR1cm4gbiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkQW55KG4pIHtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSB8fCByZWFjaGVkTWF4KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihuKSB7XG4gICAgaWYgKCFyZWFjaGVkQW55KG4pKSByZXR1cm4gbjtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPZmZzZXQobikge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm4gbjtcbiAgICByZXR1cm4gbiAtIGxlbmd0aCAqIE1hdGguY2VpbCgobiAtIG1heCkgLyBsZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGVuZ3RoLFxuICAgIG1heCxcbiAgICBtaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHJlYWNoZWRBbnksXG4gICAgcmVhY2hlZE1heCxcbiAgICByZWFjaGVkTWluLFxuICAgIHJlbW92ZU9mZnNldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ291bnRlcihtYXgsIHN0YXJ0LCBsb29wKSB7XG4gIGNvbnN0IHtcbiAgICBjb25zdHJhaW5cbiAgfSA9IExpbWl0KDAsIG1heCk7XG4gIGNvbnN0IGxvb3BFbmQgPSBtYXggKyAxO1xuICBsZXQgY291bnRlciA9IHdpdGhpbkxpbWl0KHN0YXJ0KTtcbiAgZnVuY3Rpb24gd2l0aGluTGltaXQobikge1xuICAgIHJldHVybiAhbG9vcCA/IGNvbnN0cmFpbihuKSA6IG1hdGhBYnMoKGxvb3BFbmQgKyBuKSAlIGxvb3BFbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIGNvdW50ZXIgPSB3aXRoaW5MaW1pdChuKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHJldHVybiBjbG9uZSgpLnNldChnZXQoKSArIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBDb3VudGVyKG1heCwgZ2V0KCksIGxvb3ApO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgY2xvbmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdIYW5kbGVyKGF4aXMsIHJvb3ROb2RlLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGFyZ2V0LCBkcmFnVHJhY2tlciwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgYmFzZUZyaWN0aW9uLCB3YXRjaERyYWcpIHtcbiAgY29uc3Qge1xuICAgIGNyb3NzOiBjcm9zc0F4aXMsXG4gICAgZGlyZWN0aW9uXG4gIH0gPSBheGlzO1xuICBjb25zdCBmb2N1c05vZGVzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbiAgY29uc3Qgbm9uUGFzc2l2ZUV2ZW50ID0ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGluaXRFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRyYWdFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGdvVG9OZXh0VGhyZXNob2xkID0gTGltaXQoNTAsIDIyNSkuY29uc3RyYWluKHBlcmNlbnRPZlZpZXcubWVhc3VyZSgyMCkpO1xuICBjb25zdCBzbmFwRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogMzAwLFxuICAgIHRvdWNoOiA0MDBcbiAgfTtcbiAgY29uc3QgZnJlZUZvcmNlQm9vc3QgPSB7XG4gICAgbW91c2U6IDUwMCxcbiAgICB0b3VjaDogNjAwXG4gIH07XG4gIGNvbnN0IGJhc2VTcGVlZCA9IGRyYWdGcmVlID8gNDMgOiAyNTtcbiAgbGV0IGlzTW92aW5nID0gZmFsc2U7XG4gIGxldCBzdGFydFNjcm9sbCA9IDA7XG4gIGxldCBzdGFydENyb3NzID0gMDtcbiAgbGV0IHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRDbGljayA9IGZhbHNlO1xuICBsZXQgaXNNb3VzZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaERyYWcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkb3duSWZBbGxvd2VkKGV2dCkge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaERyYWcpIHx8IHdhdGNoRHJhZyhlbWJsYUFwaSwgZXZ0KSkgZG93bihldnQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gcm9vdE5vZGU7XG4gICAgaW5pdEV2ZW50cy5hZGQobm9kZSwgJ2RyYWdzdGFydCcsIGV2dCA9PiBldnQucHJldmVudERlZmF1bHQoKSwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNobW92ZScsICgpID0+IHVuZGVmaW5lZCwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNoZW5kJywgKCkgPT4gdW5kZWZpbmVkKS5hZGQobm9kZSwgJ3RvdWNoc3RhcnQnLCBkb3duSWZBbGxvd2VkKS5hZGQobm9kZSwgJ21vdXNlZG93bicsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAndG91Y2hjYW5jZWwnLCB1cCkuYWRkKG5vZGUsICdjb250ZXh0bWVudScsIHVwKS5hZGQobm9kZSwgJ2NsaWNrJywgY2xpY2ssIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaW5pdEV2ZW50cy5jbGVhcigpO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGREcmFnRXZlbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSBpc01vdXNlID8gb3duZXJEb2N1bWVudCA6IHJvb3ROb2RlO1xuICAgIGRyYWdFdmVudHMuYWRkKG5vZGUsICd0b3VjaG1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCB1cCkuYWRkKG5vZGUsICdtb3VzZW1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAnbW91c2V1cCcsIHVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZvY3VzTm9kZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lIHx8ICcnO1xuICAgIHJldHVybiBmb2N1c05vZGVzLmluY2x1ZGVzKG5vZGVOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUJvb3N0KCkge1xuICAgIGNvbnN0IGJvb3N0ID0gZHJhZ0ZyZWUgPyBmcmVlRm9yY2VCb29zdCA6IHNuYXBGb3JjZUJvb3N0O1xuICAgIGNvbnN0IHR5cGUgPSBpc01vdXNlID8gJ21vdXNlJyA6ICd0b3VjaCc7XG4gICAgcmV0dXJuIGJvb3N0W3R5cGVdO1xuICB9XG4gIGZ1bmN0aW9uIGFsbG93ZWRGb3JjZShmb3JjZSwgdGFyZ2V0Q2hhbmdlZCkge1xuICAgIGNvbnN0IG5leHQgPSBpbmRleC5hZGQobWF0aFNpZ24oZm9yY2UpICogLTEpO1xuICAgIGNvbnN0IGJhc2VGb3JjZSA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpLmRpc3RhbmNlO1xuICAgIGlmIChkcmFnRnJlZSB8fCBtYXRoQWJzKGZvcmNlKSA8IGdvVG9OZXh0VGhyZXNob2xkKSByZXR1cm4gYmFzZUZvcmNlO1xuICAgIGlmIChza2lwU25hcHMgJiYgdGFyZ2V0Q2hhbmdlZCkgcmV0dXJuIGJhc2VGb3JjZSAqIDAuNTtcbiAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgobmV4dC5nZXQoKSwgMCkuZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihldnQpIHtcbiAgICBjb25zdCBpc01vdXNlRXZ0ID0gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpO1xuICAgIGlzTW91c2UgPSBpc01vdXNlRXZ0O1xuICAgIHByZXZlbnRDbGljayA9IGRyYWdGcmVlICYmIGlzTW91c2VFdnQgJiYgIWV2dC5idXR0b25zICYmIGlzTW92aW5nO1xuICAgIGlzTW92aW5nID0gZGVsdGFBYnModGFyZ2V0LmdldCgpLCBsb2NhdGlvbi5nZXQoKSkgPj0gMjtcbiAgICBpZiAoaXNNb3VzZUV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgaWYgKGlzRm9jdXNOb2RlKGV2dC50YXJnZXQpKSByZXR1cm47XG4gICAgcG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgZHJhZ1RyYWNrZXIucG9pbnRlckRvd24oZXZ0KTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDApLnVzZUR1cmF0aW9uKDApO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgIGFkZERyYWdFdmVudHMoKTtcbiAgICBzdGFydFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIHN0YXJ0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyRG93bicpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZ0KSB7XG4gICAgY29uc3QgaXNUb3VjaEV2dCA9ICFpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaWYgKGlzVG91Y2hFdnQgJiYgZXZ0LnRvdWNoZXMubGVuZ3RoID49IDIpIHJldHVybiB1cChldnQpO1xuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0KTtcbiAgICBjb25zdCBsYXN0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGNvbnN0IGRpZmZTY3JvbGwgPSBkZWx0YUFicyhsYXN0U2Nyb2xsLCBzdGFydFNjcm9sbCk7XG4gICAgY29uc3QgZGlmZkNyb3NzID0gZGVsdGFBYnMobGFzdENyb3NzLCBzdGFydENyb3NzKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGwgJiYgIWlzTW91c2UpIHtcbiAgICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybiB1cChldnQpO1xuICAgICAgcHJldmVudFNjcm9sbCA9IGRpZmZTY3JvbGwgPiBkaWZmQ3Jvc3M7XG4gICAgICBpZiAoIXByZXZlbnRTY3JvbGwpIHJldHVybiB1cChldnQpO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gZHJhZ1RyYWNrZXIucG9pbnRlck1vdmUoZXZ0KTtcbiAgICBpZiAoZGlmZlNjcm9sbCA+IGRyYWdUaHJlc2hvbGQpIHByZXZlbnRDbGljayA9IHRydWU7XG4gICAgc2Nyb2xsQm9keS51c2VGcmljdGlvbigwLjMpLnVzZUR1cmF0aW9uKDAuNzUpO1xuICAgIGFuaW1hdGlvbi5zdGFydCgpO1xuICAgIHRhcmdldC5hZGQoZGlyZWN0aW9uKGRpZmYpKTtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiB1cChldnQpIHtcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSBzY3JvbGxUYXJnZXQuYnlEaXN0YW5jZSgwLCBmYWxzZSk7XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlZCA9IGN1cnJlbnRMb2NhdGlvbi5pbmRleCAhPT0gaW5kZXguZ2V0KCk7XG4gICAgY29uc3QgcmF3Rm9yY2UgPSBkcmFnVHJhY2tlci5wb2ludGVyVXAoZXZ0KSAqIGZvcmNlQm9vc3QoKTtcbiAgICBjb25zdCBmb3JjZSA9IGFsbG93ZWRGb3JjZShkaXJlY3Rpb24ocmF3Rm9yY2UpLCB0YXJnZXRDaGFuZ2VkKTtcbiAgICBjb25zdCBmb3JjZUZhY3RvciA9IGZhY3RvckFicyhyYXdGb3JjZSwgZm9yY2UpO1xuICAgIGNvbnN0IHNwZWVkID0gYmFzZVNwZWVkIC0gMTAgKiBmb3JjZUZhY3RvcjtcbiAgICBjb25zdCBmcmljdGlvbiA9IGJhc2VGcmljdGlvbiArIGZvcmNlRmFjdG9yIC8gNTA7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICAgIHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgICBkcmFnRXZlbnRzLmNsZWFyKCk7XG4gICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbihzcGVlZCkudXNlRnJpY3Rpb24oZnJpY3Rpb24pO1xuICAgIHNjcm9sbFRvLmRpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpO1xuICAgIGlzTW91c2UgPSBmYWxzZTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgncG9pbnRlclVwJyk7XG4gIH1cbiAgZnVuY3Rpb24gY2xpY2soZXZ0KSB7XG4gICAgaWYgKHByZXZlbnRDbGljaykge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwcmV2ZW50Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgcmV0dXJuIHBvaW50ZXJJc0Rvd247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgcG9pbnRlckRvd25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IGxvZ0ludGVydmFsID0gMTcwO1xuICBsZXQgc3RhcnRFdmVudDtcbiAgbGV0IGxhc3RFdmVudDtcbiAgZnVuY3Rpb24gcmVhZFRpbWUoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50aW1lU3RhbXA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFBvaW50KGV2dCwgZXZ0QXhpcykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gZXZ0QXhpcyB8fCBheGlzLnNjcm9sbDtcbiAgICBjb25zdCBjb29yZCA9IGBjbGllbnQke3Byb3BlcnR5ID09PSAneCcgPyAnWCcgOiAnWSd9YDtcbiAgICByZXR1cm4gKGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSA/IGV2dCA6IGV2dC50b3VjaGVzWzBdKVtjb29yZF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZ0KSB7XG4gICAgc3RhcnRFdmVudCA9IGV2dDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIHJlYWRQb2ludChldnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGV2dCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkUG9pbnQoZXZ0KSAtIHJlYWRQb2ludChsYXN0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCkgPiBsb2dJbnRlcnZhbDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgaWYgKGV4cGlyZWQpIHN0YXJ0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKGV2dCkge1xuICAgIGlmICghc3RhcnRFdmVudCB8fCAhbGFzdEV2ZW50KSByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmRHJhZyA9IHJlYWRQb2ludChsYXN0RXZlbnQpIC0gcmVhZFBvaW50KHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gcmVhZFRpbWUoZXZ0KSAtIHJlYWRUaW1lKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUobGFzdEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGNvbnN0IGZvcmNlID0gZGlmZkRyYWcgLyBkaWZmVGltZTtcbiAgICBjb25zdCBpc0ZsaWNrID0gZGlmZlRpbWUgJiYgIWV4cGlyZWQgJiYgbWF0aEFicyhmb3JjZSkgPiAwLjE7XG4gICAgcmV0dXJuIGlzRmxpY2sgPyBmb3JjZSA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBwb2ludGVyRG93bixcbiAgICBwb2ludGVyTW92ZSxcbiAgICBwb2ludGVyVXAsXG4gICAgcmVhZFBvaW50XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBOb2RlUmVjdHMoKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFRvcCxcbiAgICAgIG9mZnNldExlZnQsXG4gICAgICBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCxcbiAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSkge1xuICBmdW5jdGlvbiBtZWFzdXJlKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgKiAobiAvIDEwMCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSB7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGFpbmVyID0gZW50cnkudGFyZ2V0ID09PSBjb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBjb25zdCBsYXN0U2l6ZSA9IGlzQ29udGFpbmVyID8gY29udGFpbmVyU2l6ZSA6IHNsaWRlU2l6ZXNbc2xpZGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSByZWFkU2l6ZShpc0NvbnRhaW5lciA/IGNvbnRhaW5lciA6IHNsaWRlc1tzbGlkZUluZGV4XSk7XG4gICAgICAgIGNvbnN0IGRpZmZTaXplID0gbWF0aEFicyhuZXdTaXplIC0gbGFzdFNpemUpO1xuICAgICAgICBpZiAoZGlmZlNpemUgPj0gMC41KSB7XG4gICAgICAgICAgb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFJlc2l6ZSkgfHwgd2F0Y2hSZXNpemUoZW1ibGFBcGksIGVudHJpZXMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvYnNlcnZlTm9kZXMgPSBbY29udGFpbmVyXS5jb25jYXQoc2xpZGVzKTtcbiAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IGJvZHlWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2VlaygpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgaXNJbnN0YW50ID0gIXNjcm9sbER1cmF0aW9uO1xuICAgIGxldCBkaXJlY3Rpb25EaWZmID0gMDtcbiAgICBpZiAoaXNJbnN0YW50KSB7XG4gICAgICBib2R5VmVsb2NpdHkgPSAwO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVZlbG9jaXR5ICs9IGRpZmYgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIGJvZHlWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IGJvZHlWZWxvY2l0eTtcbiAgICAgIGxvY2F0aW9uLmFkZChib2R5VmVsb2NpdHkpO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICB9XG4gICAgc2Nyb2xsRGlyZWN0aW9uID0gbWF0aFNpZ24oZGlyZWN0aW9uRGlmZik7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBib2R5VmVsb2NpdHk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB1c2VEdXJhdGlvbihiYXNlRHVyYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VGcmljdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRnJpY3Rpb24oYmFzZUZyaWN0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEdXJhdGlvbihuKSB7XG4gICAgc2Nyb2xsRHVyYXRpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZyaWN0aW9uKG4pIHtcbiAgICBzY3JvbGxGcmljdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZHVyYXRpb24sXG4gICAgdmVsb2NpdHksXG4gICAgc2VlayxcbiAgICBzZXR0bGVkLFxuICAgIHVzZUJhc2VGcmljdGlvbixcbiAgICB1c2VCYXNlRHVyYXRpb24sXG4gICAgdXNlRnJpY3Rpb24sXG4gICAgdXNlRHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvdW5kcyhsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldykge1xuICBjb25zdCBwdWxsQmFja1RocmVzaG9sZCA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSgxMCk7XG4gIGNvbnN0IGVkZ2VPZmZzZXRUb2xlcmFuY2UgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoNTApO1xuICBjb25zdCBmcmljdGlvbkxpbWl0ID0gTGltaXQoMC4xLCAwLjk5KTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZENvbnN0cmFpbigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkodGFyZ2V0LmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueShvZmZzZXRMb2NhdGlvbi5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4ocG9pbnRlckRvd24pIHtcbiAgICBpZiAoIXNob3VsZENvbnN0cmFpbigpKSByZXR1cm47XG4gICAgY29uc3QgZWRnZSA9IGxpbWl0LnJlYWNoZWRNaW4ob2Zmc2V0TG9jYXRpb24uZ2V0KCkpID8gJ21pbicgOiAnbWF4JztcbiAgICBjb25zdCBkaWZmVG9FZGdlID0gbWF0aEFicyhsaW1pdFtlZGdlXSAtIG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBvZmZzZXRMb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBmcmljdGlvbiA9IGZyaWN0aW9uTGltaXQuY29uc3RyYWluKGRpZmZUb0VkZ2UgLyBlZGdlT2Zmc2V0VG9sZXJhbmNlKTtcbiAgICB0YXJnZXQuc3VidHJhY3QoZGlmZlRvVGFyZ2V0ICogZnJpY3Rpb24pO1xuICAgIGlmICghcG9pbnRlckRvd24gJiYgbWF0aEFicyhkaWZmVG9UYXJnZXQpIDwgcHVsbEJhY2tUaHJlc2hvbGQpIHtcbiAgICAgIHRhcmdldC5zZXQobGltaXQuY29uc3RyYWluKHRhcmdldC5nZXQoKSkpO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigyNSkudXNlQmFzZUZyaWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjb25zdHJhaW4sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSkge1xuICBjb25zdCBzY3JvbGxCb3VuZHMgPSBMaW1pdCgtY29udGVudFNpemUgKyB2aWV3U2l6ZSwgMCk7XG4gIGNvbnN0IHNuYXBzQm91bmRlZCA9IG1lYXN1cmVCb3VuZGVkKCk7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5MaW1pdCA9IGZpbmRTY3JvbGxDb250YWluTGltaXQoKTtcbiAgY29uc3Qgc25hcHNDb250YWluZWQgPSBtZWFzdXJlQ29udGFpbmVkKCk7XG4gIGZ1bmN0aW9uIHVzZVBpeGVsVG9sZXJhbmNlKGJvdW5kLCBzbmFwKSB7XG4gICAgcmV0dXJuIGRlbHRhQWJzKGJvdW5kLCBzbmFwKSA8IDE7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0gPSBzY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCBzbmFwID0gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gbWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtaW4sIHNuYXApKSByZXR1cm4gbWluO1xuICAgICAgaWYgKHVzZVBpeGVsVG9sZXJhbmNlKG1heCwgc25hcCkpIHJldHVybiBtYXg7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9KS5tYXAoc2Nyb2xsQm91bmQgPT4gcGFyc2VGbG9hdChzY3JvbGxCb3VuZC50b0ZpeGVkKDMpKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUNvbnRhaW5lZCgpIHtcbiAgICBpZiAoY29udGVudFNpemUgPD0gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgcmV0dXJuIFtzY3JvbGxCb3VuZHMubWF4XTtcbiAgICBpZiAoY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcycpIHJldHVybiBzbmFwc0JvdW5kZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgICByZXR1cm4gc25hcHNCb3VuZGVkLnNsaWNlKG1pbiwgbWF4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKSB7XG4gIGNvbnN0IG1heCA9IHNjcm9sbFNuYXBzWzBdO1xuICBjb25zdCBtaW4gPSBsb29wID8gbWF4IC0gY29udGVudFNpemUgOiBhcnJheUxhc3Qoc2Nyb2xsU25hcHMpO1xuICBjb25zdCBsaW1pdCA9IExpbWl0KG1pbiwgbWF4KTtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIHZlY3RvcnMpIHtcbiAgY29uc3Qgam9pbnRTYWZldHkgPSAwLjE7XG4gIGNvbnN0IG1pbiA9IGxpbWl0Lm1pbiArIGpvaW50U2FmZXR5O1xuICBjb25zdCBtYXggPSBsaW1pdC5tYXggKyBqb2ludFNhZmV0eTtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVhY2hlZE1heFxuICB9ID0gTGltaXQobWluLCBtYXgpO1xuICBmdW5jdGlvbiBzaG91bGRMb29wKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHJldHVybiByZWFjaGVkTWF4KG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkgcmV0dXJuIHJlYWNoZWRNaW4ob2Zmc2V0TG9jYXRpb24uZ2V0KCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGRpcmVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTG9vcChkaXJlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgbG9vcERpc3RhbmNlID0gY29udGVudFNpemUgKiAoZGlyZWN0aW9uICogLTEpO1xuICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHYuYWRkKGxvb3BEaXN0YW5jZSkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbG9vcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpIHtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBsZW5ndGhcbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBnZXQobikge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IG4gLSBtYXg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGN1cnJlbnRMb2NhdGlvbiAvIC1sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3QgYWxpZ25tZW50cyA9IG1lYXN1cmVTaXplcygpLm1hcChhbGlnbm1lbnQubWVhc3VyZSk7XG4gIGNvbnN0IHNuYXBzID0gbWVhc3VyZVVuYWxpZ25lZCgpO1xuICBjb25zdCBzbmFwc0FsaWduZWQgPSBtZWFzdXJlQWxpZ25lZCgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZXMoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNsaWRlUmVjdHMpLm1hcChyZWN0cyA9PiBhcnJheUxhc3QocmVjdHMpW2VuZEVkZ2VdIC0gcmVjdHNbMF1bc3RhcnRFZGdlXSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVVbmFsaWduZWQoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKHJlY3QgPT4gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdKS5tYXAoc25hcCA9PiAtbWF0aEFicyhzbmFwKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFsaWduZWQoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNuYXBzKS5tYXAoZyA9PiBnWzBdKS5tYXAoKHNuYXAsIGluZGV4KSA9PiBzbmFwICsgYWxpZ25tZW50c1tpbmRleF0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVJlZ2lzdHJ5KGNvbnRhaW5TbmFwcywgY29udGFpblNjcm9sbCwgc2Nyb2xsU25hcHMsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKHNjcm9sbFNuYXBzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtzbGlkZUluZGV4ZXNdO1xuICAgIGlmIChkb05vdENvbnRhaW4pIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzLnNsaWNlKG1pbiwgbWF4KS5tYXAoKGdyb3VwLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChncm91cHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0KGdyb3Vwc1swXSkgKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3RJbmRleChzbGlkZUluZGV4ZXMpIC0gYXJyYXlMYXN0KGdyb3VwcylbMF0gKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlLCBhcnJheUxhc3QoZ3JvdXBzKVswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0VmVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkQW55LFxuICAgIHJlbW92ZU9mZnNldCxcbiAgICBjb25zdHJhaW5cbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBtaW5EaXN0YW5jZShkaXN0YW5jZXMpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IG1hdGhBYnMoYSkgLSBtYXRoQWJzKGIpKVswXTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxvb3AgPyByZW1vdmVPZmZzZXQodGFyZ2V0KSA6IGNvbnN0cmFpbih0YXJnZXQpO1xuICAgIGNvbnN0IGFzY0RpZmZzVG9TbmFwcyA9IHNjcm9sbFNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBkaWZmOiBzaG9ydGN1dChzbmFwIC0gZGlzdGFuY2UsIDApLFxuICAgICAgaW5kZXhcbiAgICB9KSkuc29ydCgoZDEsIGQyKSA9PiBtYXRoQWJzKGQxLmRpZmYpIC0gbWF0aEFicyhkMi5kaWZmKSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gYXNjRGlmZnNUb1NuYXBzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzaG9ydGN1dCh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldHMgPSBbdGFyZ2V0LCB0YXJnZXQgKyBjb250ZW50U2l6ZSwgdGFyZ2V0IC0gY29udGVudFNpemVdO1xuICAgIGlmICghbG9vcCkgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAoIWRpcmVjdGlvbikgcmV0dXJuIG1pbkRpc3RhbmNlKHRhcmdldHMpO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKHQgPT4gbWF0aFNpZ24odCkgPT09IGRpcmVjdGlvbik7XG4gICAgaWYgKG1hdGNoaW5nVGFyZ2V0cy5sZW5ndGgpIHJldHVybiBtaW5EaXN0YW5jZShtYXRjaGluZ1RhcmdldHMpO1xuICAgIHJldHVybiBhcnJheUxhc3QodGFyZ2V0cykgLSBjb250ZW50U2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBieUluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0VmVjdG9yLmdldCgpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2hvcnRjdXQoZGlmZlRvU25hcCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnlEaXN0YW5jZShkaXN0YW5jZSwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFZlY3Rvci5nZXQoKSArIGRpc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHRhcmdldFNuYXBEaXN0YW5jZVxuICAgIH0gPSBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlYWNoZWRCb3VuZCA9ICFsb29wICYmIHJlYWNoZWRBbnkodGFyZ2V0KTtcbiAgICBpZiAoIXNuYXAgfHwgcmVhY2hlZEJvdW5kKSByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFNuYXBEaXN0YW5jZTtcbiAgICBjb25zdCBzbmFwRGlzdGFuY2UgPSBkaXN0YW5jZSArIHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiBzbmFwRGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYnlEaXN0YW5jZSxcbiAgICBieUluZGV4LFxuICAgIHNob3J0Y3V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4Q3VycmVudCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXRWZWN0b3IsIGV2ZW50SGFuZGxlcikge1xuICBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSB0YXJnZXQuZGlzdGFuY2U7XG4gICAgY29uc3QgaW5kZXhEaWZmID0gdGFyZ2V0LmluZGV4ICE9PSBpbmRleEN1cnJlbnQuZ2V0KCk7XG4gICAgdGFyZ2V0VmVjdG9yLmFkZChkaXN0YW5jZURpZmYpO1xuICAgIGlmIChkaXN0YW5jZURpZmYpIHtcbiAgICAgIGlmIChzY3JvbGxCb2R5LmR1cmF0aW9uKCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMSk7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUsIGV2ZW50SGFuZGxlcikge1xuICBsZXQgbGFzdFRhYlByZXNzVGltZSA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZXZlbnRTdG9yZS5hZGQoZG9jdW1lbnQsICdrZXlkb3duJywgcmVnaXN0ZXJUYWJQcmVzcywgZmFsc2UpO1xuICAgIHNsaWRlcy5mb3JFYWNoKGFkZFNsaWRlRm9jdXNFdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJUYWJQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSAnVGFiJykgbGFzdFRhYlByZXNzVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFNsaWRlRm9jdXNFdmVudChzbGlkZSkge1xuICAgIGNvbnN0IGZvY3VzID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGlmZlRpbWUgPSBub3dUaW1lIC0gbGFzdFRhYlByZXNzVGltZTtcbiAgICAgIGlmIChkaWZmVGltZSA+IDEwKSByZXR1cm47XG4gICAgICByb290LnNjcm9sbExlZnQgPSAwO1xuICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZUZvY3VzJyk7XG4gICAgfTtcbiAgICBldmVudFN0b3JlLmFkZChzbGlkZSwgJ2ZvY3VzJywgZm9jdXMsIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGNvbnRhaW5lcikge1xuICBjb25zdCB0cmFuc2xhdGUgPSBheGlzLnNjcm9sbCA9PT0gJ3gnID8geCA6IHk7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24geChuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgke259cHgsMHB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHkobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCR7bn1weCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUoYXhpcy5kaXJlY3Rpb24odGFyZ2V0KSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGRpc2FibGVkID0gIWFjdGl2ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICBpZiAoIWNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjbGVhcixcbiAgICB0byxcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlTG9vcGVyKGF4aXMsIHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc2xpZGVTaXplcywgc2xpZGVTaXplc1dpdGhHYXBzLCBzbmFwcywgc2Nyb2xsU25hcHMsIG9mZnNldExvY2F0aW9uLCBzbGlkZXMpIHtcbiAgY29uc3Qgcm91bmRpbmdTYWZldHkgPSAwLjU7XG4gIGNvbnN0IGFzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2Fwcyk7XG4gIGNvbnN0IGRlc2NJdGVtcyA9IGFycmF5S2V5cyhzbGlkZVNpemVzV2l0aEdhcHMpLnJldmVyc2UoKTtcbiAgY29uc3QgbG9vcFBvaW50cyA9IHN0YXJ0UG9pbnRzKCkuY29uY2F0KGVuZFBvaW50cygpKTtcbiAgZnVuY3Rpb24gcmVtb3ZlU2xpZGVTaXplcyhpbmRleGVzLCBmcm9tKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMucmVkdWNlKChhLCBpKSA9PiB7XG4gICAgICByZXR1cm4gYSAtIHNsaWRlU2l6ZXNXaXRoR2Fwc1tpXTtcbiAgICB9LCBmcm9tKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJbkdhcChpbmRleGVzLCBnYXApIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0dhcCA9IHJlbW92ZVNsaWRlU2l6ZXMoYSwgZ2FwKTtcbiAgICAgIHJldHVybiByZW1haW5pbmdHYXAgPiAwID8gYS5jb25jYXQoW2ldKSA6IGE7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRTbGlkZUJvdW5kcyhvZmZzZXQpIHtcbiAgICByZXR1cm4gc25hcHMubWFwKChzbmFwLCBpbmRleCkgPT4gKHtcbiAgICAgIHN0YXJ0OiBzbmFwIC0gc2xpZGVTaXplc1tpbmRleF0gKyByb3VuZGluZ1NhZmV0eSArIG9mZnNldCxcbiAgICAgIGVuZDogc25hcCArIHZpZXdTaXplIC0gcm91bmRpbmdTYWZldHkgKyBvZmZzZXRcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZExvb3BQb2ludHMoaW5kZXhlcywgb2Zmc2V0LCBpc0VuZEVkZ2UpIHtcbiAgICBjb25zdCBzbGlkZUJvdW5kcyA9IGZpbmRTbGlkZUJvdW5kcyhvZmZzZXQpO1xuICAgIHJldHVybiBpbmRleGVzLm1hcChpbmRleCA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsID0gaXNFbmRFZGdlID8gMCA6IC1jb250ZW50U2l6ZTtcbiAgICAgIGNvbnN0IGFsdGVyZWQgPSBpc0VuZEVkZ2UgPyBjb250ZW50U2l6ZSA6IDA7XG4gICAgICBjb25zdCBib3VuZEVkZ2UgPSBpc0VuZEVkZ2UgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICBjb25zdCBsb29wUG9pbnQgPSBzbGlkZUJvdW5kc1tpbmRleF1bYm91bmRFZGdlXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBsb29wUG9pbnQsXG4gICAgICAgIHNsaWRlTG9jYXRpb246IFZlY3RvcjFEKC0xKSxcbiAgICAgICAgdHJhbnNsYXRlOiBUcmFuc2xhdGUoYXhpcywgc2xpZGVzW2luZGV4XSksXG4gICAgICAgIHRhcmdldDogKCkgPT4gb2Zmc2V0TG9jYXRpb24uZ2V0KCkgPiBsb29wUG9pbnQgPyBpbml0aWFsIDogYWx0ZXJlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSBzY3JvbGxTbmFwc1swXTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoZGVzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBjb250ZW50U2l6ZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGVuZFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSB2aWV3U2l6ZSAtIHNjcm9sbFNuYXBzWzBdIC0gMTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoYXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIC1jb250ZW50U2l6ZSwgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuTG9vcCgpIHtcbiAgICByZXR1cm4gbG9vcFBvaW50cy5ldmVyeSgoe1xuICAgICAgaW5kZXhcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBvdGhlckluZGV4ZXMgPSBhc2NJdGVtcy5maWx0ZXIoaSA9PiBpICE9PSBpbmRleCk7XG4gICAgICByZXR1cm4gcmVtb3ZlU2xpZGVTaXplcyhvdGhlckluZGV4ZXMsIHZpZXdTaXplKSA8PSAwLjE7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHNsaWRlTG9jYXRpb25cbiAgICAgIH0gPSBsb29wUG9pbnQ7XG4gICAgICBjb25zdCBzaGlmdExvY2F0aW9uID0gdGFyZ2V0KCk7XG4gICAgICBpZiAoc2hpZnRMb2NhdGlvbiA9PT0gc2xpZGVMb2NhdGlvbi5nZXQoKSkgcmV0dXJuO1xuICAgICAgdHJhbnNsYXRlLnRvKHNoaWZ0TG9jYXRpb24pO1xuICAgICAgc2xpZGVMb2NhdGlvbi5zZXQoc2hpZnRMb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiBsb29wUG9pbnQudHJhbnNsYXRlLmNsZWFyKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgY2FuTG9vcCxcbiAgICBjbGVhcixcbiAgICBsb29wLFxuICAgIGxvb3BQb2ludHNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSB7XG4gIGxldCBtdXRhdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoU2xpZGVzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZW1ibGFBcGkucmVJbml0KCk7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0NoYW5nZWQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGlmIChpc0Jvb2xlYW4od2F0Y2hTbGlkZXMpIHx8IHdhdGNoU2xpZGVzKGVtYmxhQXBpLCBtdXRhdGlvbnMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXIpIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCB0aHJlc2hvbGQpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uRW50cnlNYXAgPSB7fTtcbiAgbGV0IGluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IGludGVyc2VjdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgICBpblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzSW5WaWV3Jyk7XG4gICAgfSwge1xuICAgICAgcm9vdDogY29udGFpbmVyLnBhcmVudEVsZW1lbnQsXG4gICAgICB0aHJlc2hvbGRcbiAgICB9KTtcbiAgICBzbGlkZXMuZm9yRWFjaChzbGlkZSA9PiBpbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHNsaWRlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIGludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXMoaW50ZXJzZWN0aW9uRW50cnlNYXApLnJlZHVjZSgobGlzdCwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChzbGlkZUluZGV4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF07XG4gICAgICBjb25zdCBpblZpZXdNYXRjaCA9IGluVmlldyAmJiBpc0ludGVyc2VjdGluZztcbiAgICAgIGNvbnN0IG5vdEluVmlld01hdGNoID0gIWluVmlldyAmJiAhaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBpZiAoaW5WaWV3TWF0Y2ggfHwgbm90SW5WaWV3TWF0Y2gpIGxpc3QucHVzaChpbmRleCk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGluVmlldyA9IHRydWUpIHtcbiAgICBpZiAoaW5WaWV3ICYmIGluVmlld0NhY2hlKSByZXR1cm4gaW5WaWV3Q2FjaGU7XG4gICAgaWYgKCFpblZpZXcgJiYgbm90SW5WaWV3Q2FjaGUpIHJldHVybiBub3RJblZpZXdDYWNoZTtcbiAgICBjb25zdCBzbGlkZUluZGV4ZXMgPSBjcmVhdGVJblZpZXdMaXN0KGluVmlldyk7XG4gICAgaWYgKGluVmlldykgaW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgaWYgKCFpblZpZXcpIG5vdEluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBzbGlkZUluZGV4ZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVNpemVzKGF4aXMsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlcywgcmVhZEVkZ2VHYXAsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IHtcbiAgICBtZWFzdXJlU2l6ZSxcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qgd2l0aEVkZ2VHYXAgPSBzbGlkZVJlY3RzWzBdICYmIHJlYWRFZGdlR2FwO1xuICBjb25zdCBzdGFydEdhcCA9IG1lYXN1cmVTdGFydEdhcCgpO1xuICBjb25zdCBlbmRHYXAgPSBtZWFzdXJlRW5kR2FwKCk7XG4gIGNvbnN0IHNsaWRlU2l6ZXMgPSBzbGlkZVJlY3RzLm1hcChtZWFzdXJlU2l6ZSk7XG4gIGNvbnN0IHNsaWRlU2l6ZXNXaXRoR2FwcyA9IG1lYXN1cmVXaXRoR2FwcygpO1xuICBmdW5jdGlvbiBtZWFzdXJlU3RhcnRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc2xpZGVSZWN0ID0gc2xpZGVSZWN0c1swXTtcbiAgICByZXR1cm4gbWF0aEFicyhjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3Rbc3RhcnRFZGdlXSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUVuZEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYXJyYXlMYXN0KHNsaWRlcykpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoYG1hcmdpbi0ke2VuZEVkZ2V9YCkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVXaXRoR2FwcygpIHtcbiAgICByZXR1cm4gc2xpZGVSZWN0cy5tYXAoKHJlY3QsIGluZGV4LCByZWN0cykgPT4ge1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgocmVjdHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBzdGFydEdhcDtcbiAgICAgIGlmIChpc0xhc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIGVuZEdhcDtcbiAgICAgIHJldHVybiByZWN0c1tpbmRleCArIDFdW3N0YXJ0RWRnZV0gLSByZWN0W3N0YXJ0RWRnZV07XG4gICAgfSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2xpZGVTaXplcyxcbiAgICBzbGlkZVNpemVzV2l0aEdhcHMsXG4gICAgc3RhcnRHYXAsXG4gICAgZW5kR2FwXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNUb1Njcm9sbChheGlzLCB2aWV3U2l6ZSwgc2xpZGVzVG9TY3JvbGwsIGxvb3AsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHN0YXJ0R2FwLCBlbmRHYXAsIHBpeGVsVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZSxcbiAgICBkaXJlY3Rpb25cbiAgfSA9IGF4aXM7XG4gIGNvbnN0IGdyb3VwQnlOdW1iZXIgPSBpc051bWJlcihzbGlkZXNUb1Njcm9sbCk7XG4gIGZ1bmN0aW9uIGJ5TnVtYmVyKGFycmF5LCBncm91cFNpemUpIHtcbiAgICByZXR1cm4gYXJyYXlLZXlzKGFycmF5KS5maWx0ZXIoaSA9PiBpICUgZ3JvdXBTaXplID09PSAwKS5tYXAoaSA9PiBhcnJheS5zbGljZShpLCBpICsgZ3JvdXBTaXplKSk7XG4gIH1cbiAgZnVuY3Rpb24gYnlTaXplKGFycmF5KSB7XG4gICAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyYXlLZXlzKGFycmF5KS5yZWR1Y2UoKGdyb3VwcywgcmVjdEIsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByZWN0QSA9IGFycmF5TGFzdChncm91cHMpIHx8IDA7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gcmVjdEEgPT09IDA7XG4gICAgICBjb25zdCBpc0xhc3QgPSByZWN0QiA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xuICAgICAgY29uc3QgZWRnZUEgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RBXVtzdGFydEVkZ2VdO1xuICAgICAgY29uc3QgZWRnZUIgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RCXVtlbmRFZGdlXTtcbiAgICAgIGNvbnN0IGdhcEEgPSAhbG9vcCAmJiBpc0ZpcnN0ID8gZGlyZWN0aW9uKHN0YXJ0R2FwKSA6IDA7XG4gICAgICBjb25zdCBnYXBCID0gIWxvb3AgJiYgaXNMYXN0ID8gZGlyZWN0aW9uKGVuZEdhcCkgOiAwO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gbWF0aEFicyhlZGdlQiAtIGdhcEIgLSAoZWRnZUEgKyBnYXBBKSk7XG4gICAgICBpZiAoaW5kZXggJiYgY2h1bmtTaXplID4gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgZ3JvdXBzLnB1c2gocmVjdEIpO1xuICAgICAgaWYgKGlzTGFzdCkgZ3JvdXBzLnB1c2goYXJyYXkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSwgW10pLm1hcCgoY3VycmVudFNpemUsIGluZGV4LCBncm91cHMpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2l6ZSA9IE1hdGgubWF4KGdyb3Vwc1tpbmRleCAtIDFdIHx8IDApO1xuICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKHByZXZpb3VzU2l6ZSwgY3VycmVudFNpemUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdyb3VwU2xpZGVzKGFycmF5KSB7XG4gICAgcmV0dXJuIGdyb3VwQnlOdW1iZXIgPyBieU51bWJlcihhcnJheSwgc2xpZGVzVG9TY3JvbGwpIDogYnlTaXplKGFycmF5KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdyb3VwU2xpZGVzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIpIHtcbiAgLy8gT3B0aW9uc1xuICBjb25zdCB7XG4gICAgYWxpZ24sXG4gICAgYXhpczogc2Nyb2xsQXhpcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RhcnRJbmRleCxcbiAgICBsb29wLFxuICAgIGR1cmF0aW9uLFxuICAgIGRyYWdGcmVlLFxuICAgIGRyYWdUaHJlc2hvbGQsXG4gICAgaW5WaWV3VGhyZXNob2xkLFxuICAgIHNsaWRlc1RvU2Nyb2xsOiBncm91cFNsaWRlcyxcbiAgICBza2lwU25hcHMsXG4gICAgY29udGFpblNjcm9sbCxcbiAgICB3YXRjaFJlc2l6ZSxcbiAgICB3YXRjaFNsaWRlcyxcbiAgICB3YXRjaERyYWdcbiAgfSA9IG9wdGlvbnM7XG4gIC8vIE1lYXN1cmVtZW50c1xuICBjb25zdCBwaXhlbFRvbGVyYW5jZSA9IDI7XG4gIGNvbnN0IG5vZGVSZWN0cyA9IE5vZGVSZWN0cygpO1xuICBjb25zdCBjb250YWluZXJSZWN0ID0gbm9kZVJlY3RzLm1lYXN1cmUoY29udGFpbmVyKTtcbiAgY29uc3Qgc2xpZGVSZWN0cyA9IHNsaWRlcy5tYXAobm9kZVJlY3RzLm1lYXN1cmUpO1xuICBjb25zdCBheGlzID0gQXhpcyhzY3JvbGxBeGlzLCBkaXJlY3Rpb24pO1xuICBjb25zdCB2aWV3U2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gIGNvbnN0IHBlcmNlbnRPZlZpZXcgPSBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKTtcbiAgY29uc3QgYWxpZ25tZW50ID0gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSk7XG4gIGNvbnN0IGNvbnRhaW5TbmFwcyA9ICFsb29wICYmICEhY29udGFpblNjcm9sbDtcbiAgY29uc3QgcmVhZEVkZ2VHYXAgPSBsb29wIHx8ICEhY29udGFpblNjcm9sbDtcbiAgY29uc3Qge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9ID0gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdyk7XG4gIGNvbnN0IHNsaWRlc1RvU2Nyb2xsID0gU2xpZGVzVG9TY3JvbGwoYXhpcywgdmlld1NpemUsIGdyb3VwU2xpZGVzLCBsb29wLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzdGFydEdhcCwgZW5kR2FwLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfSA9IFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpO1xuICBjb25zdCBjb250ZW50U2l6ZSA9IC1hcnJheUxhc3Qoc25hcHMpICsgYXJyYXlMYXN0KHNsaWRlU2l6ZXNXaXRoR2Fwcyk7XG4gIGNvbnN0IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfSA9IFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKTtcbiAgY29uc3Qgc2Nyb2xsU25hcHMgPSBjb250YWluU25hcHMgPyBzbmFwc0NvbnRhaW5lZCA6IHNuYXBzQWxpZ25lZDtcbiAgY29uc3Qge1xuICAgIGxpbWl0XG4gIH0gPSBTY3JvbGxMaW1pdChjb250ZW50U2l6ZSwgc2Nyb2xsU25hcHMsIGxvb3ApO1xuICAvLyBJbmRleGVzXG4gIGNvbnN0IGluZGV4ID0gQ291bnRlcihhcnJheUxhc3RJbmRleChzY3JvbGxTbmFwcyksIHN0YXJ0SW5kZXgsIGxvb3ApO1xuICBjb25zdCBpbmRleFByZXZpb3VzID0gaW5kZXguY2xvbmUoKTtcbiAgY29uc3Qgc2xpZGVJbmRleGVzID0gYXJyYXlLZXlzKHNsaWRlcyk7XG4gIC8vIEFuaW1hdGlvblxuICBjb25zdCB1cGRhdGUgPSAoe1xuICAgIGRyYWdIYW5kbGVyLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0pID0+IHtcbiAgICBpZiAoIWxvb3ApIHNjcm9sbEJvdW5kcy5jb25zdHJhaW4oZHJhZ0hhbmRsZXIucG9pbnRlckRvd24oKSk7XG4gICAgc2Nyb2xsQm9keS5zZWVrKCk7XG4gIH07XG4gIGNvbnN0IHJlbmRlciA9ICh7XG4gICAgc2Nyb2xsQm9keSxcbiAgICB0cmFuc2xhdGUsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgbG9vcFxuICAgIH1cbiAgfSwgbGFnT2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBzY3JvbGxCb2R5LnZlbG9jaXR5KCk7XG4gICAgY29uc3QgaGFzU2V0dGxlZCA9IHNjcm9sbEJvZHkuc2V0dGxlZCgpO1xuICAgIGlmIChoYXNTZXR0bGVkICYmICFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKSB7XG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NldHRsZScpO1xuICAgIH1cbiAgICBpZiAoIWhhc1NldHRsZWQpIGV2ZW50SGFuZGxlci5lbWl0KCdzY3JvbGwnKTtcbiAgICBvZmZzZXRMb2NhdGlvbi5zZXQobG9jYXRpb24uZ2V0KCkgLSB2ZWxvY2l0eSArIHZlbG9jaXR5ICogbGFnT2Zmc2V0KTtcbiAgICBpZiAobG9vcCkge1xuICAgICAgc2Nyb2xsTG9vcGVyLmxvb3Aoc2Nyb2xsQm9keS5kaXJlY3Rpb24oKSk7XG4gICAgICBzbGlkZUxvb3Blci5sb29wKCk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZS50byhvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csICgpID0+IHVwZGF0ZShlbmdpbmUpLCBsYWdPZmZzZXQgPT4gcmVuZGVyKGVuZ2luZSwgbGFnT2Zmc2V0KSk7XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKTtcbiAgY29uc3Qgc2xpZGVGb2N1cyA9IFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSwgZXZlbnRIYW5kbGVyKTtcbiAgLy8gRW5naW5lXG4gIGNvbnN0IGVuZ2luZSA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIG93bmVyV2luZG93LFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBjb250YWluZXJSZWN0LFxuICAgIHNsaWRlUmVjdHMsXG4gICAgYW5pbWF0aW9uLFxuICAgIGF4aXMsXG4gICAgZHJhZ0hhbmRsZXI6IERyYWdIYW5kbGVyKGF4aXMsIHJvb3QsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB0YXJnZXQsIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgZnJpY3Rpb24sIHdhdGNoRHJhZyksXG4gICAgZXZlbnRTdG9yZSxcbiAgICBwZXJjZW50T2ZWaWV3LFxuICAgIGluZGV4LFxuICAgIGluZGV4UHJldmlvdXMsXG4gICAgbGltaXQsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgb3B0aW9ucyxcbiAgICByZXNpemVIYW5kbGVyOiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSxcbiAgICBzY3JvbGxCb2R5LFxuICAgIHNjcm9sbEJvdW5kczogU2Nyb2xsQm91bmRzKGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgdGFyZ2V0LCBzY3JvbGxCb2R5LCBwZXJjZW50T2ZWaWV3KSxcbiAgICBzY3JvbGxMb29wZXI6IFNjcm9sbExvb3Blcihjb250ZW50U2l6ZSwgbGltaXQsIG9mZnNldExvY2F0aW9uLCBbbG9jYXRpb24sIG9mZnNldExvY2F0aW9uLCB0YXJnZXRdKSxcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICBzY3JvbGxTbmFwTGlzdDogc2Nyb2xsU25hcHMubWFwKHNjcm9sbFByb2dyZXNzLmdldCksXG4gICAgc2Nyb2xsU25hcHMsXG4gICAgc2Nyb2xsVGFyZ2V0LFxuICAgIHNjcm9sbFRvLFxuICAgIHNsaWRlTG9vcGVyOiBTbGlkZUxvb3BlcihheGlzLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBvZmZzZXRMb2NhdGlvbiwgc2xpZGVzKSxcbiAgICBzbGlkZUZvY3VzLFxuICAgIHNsaWRlc0hhbmRsZXI6IFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVJbmRleGVzLFxuICAgIHNsaWRlUmVnaXN0cnksXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgdGFyZ2V0LFxuICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIGNvbnRhaW5lcilcbiAgfTtcbiAgcmV0dXJuIGVuZ2luZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xuICBsZXQgbGlzdGVuZXJzID0ge307XG4gIGxldCBhcGk7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBhcGkgPSBlbWJsYUFwaTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyc1tldnRdIHx8IFtdO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XG4gICAgZ2V0TGlzdGVuZXJzKGV2dCkuZm9yRWFjaChlID0+IGUoYXBpLCBldnQpKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBvbihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5jb25jYXQoW2NiXSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb2ZmKGV2dCwgY2IpIHtcbiAgICBsaXN0ZW5lcnNbZXZ0XSA9IGdldExpc3RlbmVycyhldnQpLmZpbHRlcihlID0+IGUgIT09IGNiKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBsaXN0ZW5lcnMgPSB7fTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZW1pdCxcbiAgICBvZmYsXG4gICAgb24sXG4gICAgY2xlYXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhbGlnbjogJ2NlbnRlcicsXG4gIGF4aXM6ICd4JyxcbiAgY29udGFpbmVyOiBudWxsLFxuICBzbGlkZXM6IG51bGwsXG4gIGNvbnRhaW5TY3JvbGw6ICd0cmltU25hcHMnLFxuICBkaXJlY3Rpb246ICdsdHInLFxuICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgaW5WaWV3VGhyZXNob2xkOiAwLFxuICBicmVha3BvaW50czoge30sXG4gIGRyYWdGcmVlOiBmYWxzZSxcbiAgZHJhZ1RocmVzaG9sZDogMTAsXG4gIGxvb3A6IGZhbHNlLFxuICBza2lwU25hcHM6IGZhbHNlLFxuICBkdXJhdGlvbjogMjUsXG4gIHN0YXJ0SW5kZXg6IDAsXG4gIGFjdGl2ZTogdHJ1ZSxcbiAgd2F0Y2hEcmFnOiB0cnVlLFxuICB3YXRjaFJlc2l6ZTogdHJ1ZSxcbiAgd2F0Y2hTbGlkZXM6IHRydWVcbn07XG5cbmZ1bmN0aW9uIE9wdGlvbnNIYW5kbGVyKG93bmVyV2luZG93KSB7XG4gIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zQSwgb3B0aW9uc0IpIHtcbiAgICByZXR1cm4gb2JqZWN0c01lcmdlRGVlcChvcHRpb25zQSwgb3B0aW9uc0IgfHwge30pO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zQXRNZWRpYSA9IG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge307XG4gICAgY29uc3QgbWF0Y2hlZE1lZGlhT3B0aW9ucyA9IG9iamVjdEtleXMob3B0aW9uc0F0TWVkaWEpLmZpbHRlcihtZWRpYSA9PiBvd25lcldpbmRvdy5tYXRjaE1lZGlhKG1lZGlhKS5tYXRjaGVzKS5tYXAobWVkaWEgPT4gb3B0aW9uc0F0TWVkaWFbbWVkaWFdKS5yZWR1Y2UoKGEsIG1lZGlhT3B0aW9uKSA9PiBtZXJnZU9wdGlvbnMoYSwgbWVkaWFPcHRpb24pLCB7fSk7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyhvcHRpb25zLCBtYXRjaGVkTWVkaWFPcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zTWVkaWFRdWVyaWVzKG9wdGlvbnNMaXN0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnNMaXN0Lm1hcChvcHRpb25zID0+IG9iamVjdEtleXMob3B0aW9ucy5icmVha3BvaW50cyB8fCB7fSkpLnJlZHVjZSgoYWNjLCBtZWRpYVF1ZXJpZXMpID0+IGFjYy5jb25jYXQobWVkaWFRdWVyaWVzKSwgW10pLm1hcChvd25lcldpbmRvdy5tYXRjaE1lZGlhKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lcmdlT3B0aW9ucyxcbiAgICBvcHRpb25zQXRNZWRpYSxcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQbHVnaW5zSGFuZGxlcihvcHRpb25zSGFuZGxlcikge1xuICBsZXQgYWN0aXZlUGx1Z2lucyA9IFtdO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpLCBwbHVnaW5zKSB7XG4gICAgYWN0aXZlUGx1Z2lucyA9IHBsdWdpbnMuZmlsdGVyKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9uc0hhbmRsZXIub3B0aW9uc0F0TWVkaWEob3B0aW9ucykuYWN0aXZlICE9PSBmYWxzZSk7XG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uaW5pdChlbWJsYUFwaSwgb3B0aW9uc0hhbmRsZXIpKTtcbiAgICByZXR1cm4gcGx1Z2lucy5yZWR1Y2UoKG1hcCwgcGx1Z2luKSA9PiBPYmplY3QuYXNzaWduKG1hcCwge1xuICAgICAgW3BsdWdpbi5uYW1lXTogcGx1Z2luXG4gICAgfSksIHt9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBhY3RpdmVQbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gcGx1Z2luLmRlc3Ryb3koKSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEVtYmxhQ2Fyb3VzZWwocm9vdCwgdXNlck9wdGlvbnMsIHVzZXJQbHVnaW5zKSB7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSByb290Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY29uc3Qgb3B0aW9uc0hhbmRsZXIgPSBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdyk7XG4gIGNvbnN0IHBsdWdpbnNIYW5kbGVyID0gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpO1xuICBjb25zdCBtZWRpYUhhbmRsZXJzID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBldmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXIoKTtcbiAgY29uc3Qge1xuICAgIG1lcmdlT3B0aW9ucyxcbiAgICBvcHRpb25zQXRNZWRpYSxcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzXG4gIH0gPSBvcHRpb25zSGFuZGxlcjtcbiAgY29uc3Qge1xuICAgIG9uLFxuICAgIG9mZixcbiAgICBlbWl0XG4gIH0gPSBldmVudEhhbmRsZXI7XG4gIGNvbnN0IHJlSW5pdCA9IHJlQWN0aXZhdGU7XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgbGV0IGVuZ2luZTtcbiAgbGV0IG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBFbWJsYUNhcm91c2VsLmdsb2JhbE9wdGlvbnMpO1xuICBsZXQgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSk7XG4gIGxldCBwbHVnaW5MaXN0ID0gW107XG4gIGxldCBwbHVnaW5BcGlzO1xuICBsZXQgY29udGFpbmVyO1xuICBsZXQgc2xpZGVzO1xuICBmdW5jdGlvbiBzdG9yZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjogdXNlckNvbnRhaW5lcixcbiAgICAgIHNsaWRlczogdXNlclNsaWRlc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGN1c3RvbUNvbnRhaW5lciA9IGlzU3RyaW5nKHVzZXJDb250YWluZXIpID8gcm9vdC5xdWVyeVNlbGVjdG9yKHVzZXJDb250YWluZXIpIDogdXNlckNvbnRhaW5lcjtcbiAgICBjb250YWluZXIgPSBjdXN0b21Db250YWluZXIgfHwgcm9vdC5jaGlsZHJlblswXTtcbiAgICBjb25zdCBjdXN0b21TbGlkZXMgPSBpc1N0cmluZyh1c2VyU2xpZGVzKSA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHVzZXJTbGlkZXMpIDogdXNlclNsaWRlcztcbiAgICBzbGlkZXMgPSBbXS5zbGljZS5jYWxsKGN1c3RvbVNsaWRlcyB8fCBjb250YWluZXIuY2hpbGRyZW4pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVuZ2luZShvcHRpb25zKSB7XG4gICAgY29uc3QgZW5naW5lID0gRW5naW5lKHJvb3QsIGNvbnRhaW5lciwgc2xpZGVzLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgb3B0aW9ucywgZXZlbnRIYW5kbGVyKTtcbiAgICBpZiAob3B0aW9ucy5sb29wICYmICFlbmdpbmUuc2xpZGVMb29wZXIuY2FuTG9vcCgpKSB7XG4gICAgICBjb25zdCBvcHRpb25zV2l0aG91dExvb3AgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGxvb3A6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjcmVhdGVFbmdpbmUob3B0aW9uc1dpdGhvdXRMb29wKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZ2luZTtcbiAgfVxuICBmdW5jdGlvbiBhY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgb3B0aW9uc0Jhc2UgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHdpdGhPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEob3B0aW9uc0Jhc2UpO1xuICAgIHBsdWdpbkxpc3QgPSB3aXRoUGx1Z2lucyB8fCBwbHVnaW5MaXN0O1xuICAgIHN0b3JlRWxlbWVudHMoKTtcbiAgICBlbmdpbmUgPSBjcmVhdGVFbmdpbmUob3B0aW9ucyk7XG4gICAgb3B0aW9uc01lZGlhUXVlcmllcyhbb3B0aW9uc0Jhc2UsIC4uLnBsdWdpbkxpc3QubWFwKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9ucyldKS5mb3JFYWNoKHF1ZXJ5ID0+IG1lZGlhSGFuZGxlcnMuYWRkKHF1ZXJ5LCAnY2hhbmdlJywgcmVBY3RpdmF0ZSkpO1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUpIHJldHVybjtcbiAgICBlbmdpbmUudHJhbnNsYXRlLnRvKGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gICAgZW5naW5lLmFuaW1hdGlvbi5pbml0KCk7XG4gICAgZW5naW5lLnNsaWRlc0luVmlldy5pbml0KCk7XG4gICAgZW5naW5lLnNsaWRlRm9jdXMuaW5pdCgpO1xuICAgIGVuZ2luZS5ldmVudEhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgaWYgKGVuZ2luZS5vcHRpb25zLmxvb3ApIGVuZ2luZS5zbGlkZUxvb3Blci5sb29wKCk7XG4gICAgaWYgKGNvbnRhaW5lci5vZmZzZXRQYXJlbnQgJiYgc2xpZGVzLmxlbmd0aCkgZW5naW5lLmRyYWdIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgcGx1Z2luQXBpcyA9IHBsdWdpbnNIYW5kbGVyLmluaXQoc2VsZiwgcGx1Z2luTGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVBY3RpdmF0ZSh3aXRoT3B0aW9ucywgd2l0aFBsdWdpbnMpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGFjdGl2YXRlKG1lcmdlT3B0aW9ucyh7XG4gICAgICBzdGFydEluZGV4XG4gICAgfSwgd2l0aE9wdGlvbnMpLCB3aXRoUGx1Z2lucyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3JlSW5pdCcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlQWN0aXZhdGUoKSB7XG4gICAgZW5naW5lLmRyYWdIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuZXZlbnRTdG9yZS5jbGVhcigpO1xuICAgIGVuZ2luZS50cmFuc2xhdGUuY2xlYXIoKTtcbiAgICBlbmdpbmUuc2xpZGVMb29wZXIuY2xlYXIoKTtcbiAgICBlbmdpbmUucmVzaXplSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgIHBsdWdpbnNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBtZWRpYUhhbmRsZXJzLmNsZWFyKCk7XG4gICAgZGVBY3RpdmF0ZSgpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdkZXN0cm95Jyk7XG4gICAgZXZlbnRIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsVG8oaW5kZXgsIGp1bXAsIGRpcmVjdGlvbikge1xuICAgIGlmICghb3B0aW9ucy5hY3RpdmUgfHwgZGVzdHJveWVkKSByZXR1cm47XG4gICAgZW5naW5lLnNjcm9sbEJvZHkudXNlQmFzZUZyaWN0aW9uKCkudXNlRHVyYXRpb24oanVtcCA9PT0gdHJ1ZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICBlbmdpbmUuc2Nyb2xsVG8uaW5kZXgoaW5kZXgsIGRpcmVjdGlvbiB8fCAwKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxOZXh0KGp1bXApIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhuZXh0LCBqdW1wLCAtMSk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJldihqdW1wKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHNjcm9sbFRvKHByZXYsIGp1bXAsIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbE5leHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgcmV0dXJuIG5leHQgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNjcm9sbFByZXYoKSB7XG4gICAgY29uc3QgcHJldiA9IGVuZ2luZS5pbmRleC5hZGQoLTEpLmdldCgpO1xuICAgIHJldHVybiBwcmV2ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxTbmFwTGlzdCgpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFNuYXBMaXN0O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsUHJvZ3Jlc3MuZ2V0KGVuZ2luZS5sb2NhdGlvbi5nZXQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0ZWRTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXguZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJldmlvdXNTY3JvbGxTbmFwKCkge1xuICAgIHJldHVybiBlbmdpbmUuaW5kZXhQcmV2aW91cy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzTm90SW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldChmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGx1Z2lucygpIHtcbiAgICByZXR1cm4gcGx1Z2luQXBpcztcbiAgfVxuICBmdW5jdGlvbiBpbnRlcm5hbEVuZ2luZSgpIHtcbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG4gIGZ1bmN0aW9uIHJvb3ROb2RlKCkge1xuICAgIHJldHVybiByb290O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRhaW5lck5vZGUoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZU5vZGVzKCkge1xuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjYW5TY3JvbGxOZXh0LFxuICAgIGNhblNjcm9sbFByZXYsXG4gICAgY29udGFpbmVyTm9kZSxcbiAgICBpbnRlcm5hbEVuZ2luZSxcbiAgICBkZXN0cm95LFxuICAgIG9mZixcbiAgICBvbixcbiAgICBlbWl0LFxuICAgIHBsdWdpbnMsXG4gICAgcHJldmlvdXNTY3JvbGxTbmFwLFxuICAgIHJlSW5pdCxcbiAgICByb290Tm9kZSxcbiAgICBzY3JvbGxOZXh0LFxuICAgIHNjcm9sbFByZXYsXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3QsXG4gICAgc2Nyb2xsVG8sXG4gICAgc2VsZWN0ZWRTY3JvbGxTbmFwLFxuICAgIHNsaWRlTm9kZXMsXG4gICAgc2xpZGVzSW5WaWV3LFxuICAgIHNsaWRlc05vdEluVmlld1xuICB9O1xuICBhY3RpdmF0ZSh1c2VyT3B0aW9ucywgdXNlclBsdWdpbnMpO1xuICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50SGFuZGxlci5lbWl0KCdpbml0JyksIDApO1xuICByZXR1cm4gc2VsZjtcbn1cbkVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiaXNOdW1iZXIiLCJzdWJqZWN0IiwiaXNTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc09iamVjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm1hdGhBYnMiLCJuIiwiTWF0aCIsImFicyIsIm1hdGhTaWduIiwic2lnbiIsImRlbHRhQWJzIiwidmFsdWVCIiwidmFsdWVBIiwiZmFjdG9yQWJzIiwiZGlmZiIsImFycmF5S2V5cyIsImFycmF5Iiwib2JqZWN0S2V5cyIsIm1hcCIsIk51bWJlciIsImFycmF5TGFzdCIsImFycmF5TGFzdEluZGV4IiwibWF4IiwibGVuZ3RoIiwiYXJyYXlJc0xhc3RJbmRleCIsImluZGV4IiwiYXJyYXlGcm9tTnVtYmVyIiwic3RhcnRBdCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwib2JqZWN0Iiwia2V5cyIsIm9iamVjdHNNZXJnZURlZXAiLCJvYmplY3RBIiwib2JqZWN0QiIsInJlZHVjZSIsIm1lcmdlZE9iamVjdHMiLCJjdXJyZW50T2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImFyZU9iamVjdHMiLCJpc01vdXNlRXZlbnQiLCJldnQiLCJvd25lcldpbmRvdyIsIk1vdXNlRXZlbnQiLCJBbGlnbm1lbnQiLCJhbGlnbiIsInZpZXdTaXplIiwicHJlZGVmaW5lZCIsInN0YXJ0IiwiY2VudGVyIiwiZW5kIiwibWVhc3VyZSIsInNlbGYiLCJFdmVudFN0b3JlIiwibGlzdGVuZXJzIiwiYWRkIiwibm9kZSIsInR5cGUiLCJoYW5kbGVyIiwib3B0aW9ucyIsInBhc3NpdmUiLCJyZW1vdmVMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGVnYWN5TWVkaWFRdWVyeUxpc3QiLCJhZGRMaXN0ZW5lciIsInB1c2giLCJjbGVhciIsImZpbHRlciIsInJlbW92ZSIsIkFuaW1hdGlvbnMiLCJvd25lckRvY3VtZW50IiwidXBkYXRlIiwicmVuZGVyIiwiZG9jdW1lbnRWaXNpYmxlSGFuZGxlciIsInRpbWVTdGVwIiwibGFzdFRpbWVTdGFtcCIsImxhZyIsImFuaW1hdGlvbkZyYW1lIiwiaW5pdCIsImhpZGRlbiIsInJlc2V0IiwiZGVzdHJveSIsInN0b3AiLCJhbmltYXRlIiwidGltZVN0YW1wIiwiZWxhcHNlZCIsImxhZ09mZnNldCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiQXhpcyIsImF4aXMiLCJjb250ZW50RGlyZWN0aW9uIiwiaXNSaWdodFRvTGVmdCIsImlzVmVydGljYWwiLCJzY3JvbGwiLCJjcm9zcyIsInN0YXJ0RWRnZSIsImdldFN0YXJ0RWRnZSIsImVuZEVkZ2UiLCJnZXRFbmRFZGdlIiwibWVhc3VyZVNpemUiLCJub2RlUmVjdCIsImhlaWdodCIsIndpZHRoIiwiZGlyZWN0aW9uIiwiTGltaXQiLCJtaW4iLCJyZWFjaGVkTWluIiwicmVhY2hlZE1heCIsInJlYWNoZWRBbnkiLCJjb25zdHJhaW4iLCJyZW1vdmVPZmZzZXQiLCJjZWlsIiwiQ291bnRlciIsImxvb3AiLCJsb29wRW5kIiwiY291bnRlciIsIndpdGhpbkxpbWl0IiwiZ2V0Iiwic2V0IiwiY2xvbmUiLCJEcmFnSGFuZGxlciIsInJvb3ROb2RlIiwidGFyZ2V0IiwiZHJhZ1RyYWNrZXIiLCJsb2NhdGlvbiIsImFuaW1hdGlvbiIsInNjcm9sbFRvIiwic2Nyb2xsQm9keSIsInNjcm9sbFRhcmdldCIsImV2ZW50SGFuZGxlciIsInBlcmNlbnRPZlZpZXciLCJkcmFnRnJlZSIsImRyYWdUaHJlc2hvbGQiLCJza2lwU25hcHMiLCJiYXNlRnJpY3Rpb24iLCJ3YXRjaERyYWciLCJjcm9zc0F4aXMiLCJmb2N1c05vZGVzIiwibm9uUGFzc2l2ZUV2ZW50IiwiaW5pdEV2ZW50cyIsImRyYWdFdmVudHMiLCJnb1RvTmV4dFRocmVzaG9sZCIsInNuYXBGb3JjZUJvb3N0IiwibW91c2UiLCJ0b3VjaCIsImZyZWVGb3JjZUJvb3N0IiwiYmFzZVNwZWVkIiwiaXNNb3ZpbmciLCJzdGFydFNjcm9sbCIsInN0YXJ0Q3Jvc3MiLCJwb2ludGVySXNEb3duIiwicHJldmVudFNjcm9sbCIsInByZXZlbnRDbGljayIsImlzTW91c2UiLCJlbWJsYUFwaSIsImRvd25JZkFsbG93ZWQiLCJkb3duIiwicHJldmVudERlZmF1bHQiLCJ1bmRlZmluZWQiLCJ1cCIsImNsaWNrIiwiYWRkRHJhZ0V2ZW50cyIsIm1vdmUiLCJpc0ZvY3VzTm9kZSIsIm5vZGVOYW1lIiwiaW5jbHVkZXMiLCJmb3JjZUJvb3N0IiwiYm9vc3QiLCJhbGxvd2VkRm9yY2UiLCJmb3JjZSIsInRhcmdldENoYW5nZWQiLCJuZXh0IiwiYmFzZUZvcmNlIiwiYnlEaXN0YW5jZSIsImRpc3RhbmNlIiwiYnlJbmRleCIsImlzTW91c2VFdnQiLCJidXR0b25zIiwiYnV0dG9uIiwicG9pbnRlckRvd24iLCJ1c2VGcmljdGlvbiIsInVzZUR1cmF0aW9uIiwicmVhZFBvaW50IiwiZW1pdCIsImlzVG91Y2hFdnQiLCJ0b3VjaGVzIiwibGFzdFNjcm9sbCIsImxhc3RDcm9zcyIsImRpZmZTY3JvbGwiLCJkaWZmQ3Jvc3MiLCJjYW5jZWxhYmxlIiwicG9pbnRlck1vdmUiLCJjdXJyZW50TG9jYXRpb24iLCJyYXdGb3JjZSIsInBvaW50ZXJVcCIsImZvcmNlRmFjdG9yIiwic3BlZWQiLCJmcmljdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsIkRyYWdUcmFja2VyIiwibG9nSW50ZXJ2YWwiLCJzdGFydEV2ZW50IiwibGFzdEV2ZW50IiwicmVhZFRpbWUiLCJldnRBeGlzIiwicHJvcGVydHkiLCJjb29yZCIsImV4cGlyZWQiLCJkaWZmRHJhZyIsImRpZmZUaW1lIiwiaXNGbGljayIsIk5vZGVSZWN0cyIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIm9mZnNldCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIlBlcmNlbnRPZlZpZXciLCJSZXNpemVIYW5kbGVyIiwiY29udGFpbmVyIiwic2xpZGVzIiwid2F0Y2hSZXNpemUiLCJub2RlUmVjdHMiLCJyZXNpemVPYnNlcnZlciIsImNvbnRhaW5lclNpemUiLCJzbGlkZVNpemVzIiwiZGVzdHJveWVkIiwicmVhZFNpemUiLCJkZWZhdWx0Q2FsbGJhY2siLCJlbnRyaWVzIiwiZW50cnkiLCJpc0NvbnRhaW5lciIsInNsaWRlSW5kZXgiLCJpbmRleE9mIiwibGFzdFNpemUiLCJuZXdTaXplIiwiZGlmZlNpemUiLCJyZUluaXQiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmVOb2RlcyIsImNvbmNhdCIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiU2Nyb2xsQm9keSIsIm9mZnNldExvY2F0aW9uIiwiYmFzZUR1cmF0aW9uIiwiYm9keVZlbG9jaXR5Iiwic2Nyb2xsRGlyZWN0aW9uIiwic2Nyb2xsRHVyYXRpb24iLCJzY3JvbGxGcmljdGlvbiIsInJhd0xvY2F0aW9uIiwicmF3TG9jYXRpb25QcmV2aW91cyIsInNlZWsiLCJpc0luc3RhbnQiLCJkaXJlY3Rpb25EaWZmIiwic2V0dGxlZCIsImR1cmF0aW9uIiwidmVsb2NpdHkiLCJ1c2VCYXNlRHVyYXRpb24iLCJ1c2VCYXNlRnJpY3Rpb24iLCJTY3JvbGxCb3VuZHMiLCJsaW1pdCIsInB1bGxCYWNrVGhyZXNob2xkIiwiZWRnZU9mZnNldFRvbGVyYW5jZSIsImZyaWN0aW9uTGltaXQiLCJkaXNhYmxlZCIsInNob3VsZENvbnN0cmFpbiIsImVkZ2UiLCJkaWZmVG9FZGdlIiwiZGlmZlRvVGFyZ2V0Iiwic3VidHJhY3QiLCJ0b2dnbGVBY3RpdmUiLCJhY3RpdmUiLCJTY3JvbGxDb250YWluIiwiY29udGVudFNpemUiLCJzbmFwc0FsaWduZWQiLCJjb250YWluU2Nyb2xsIiwicGl4ZWxUb2xlcmFuY2UiLCJzY3JvbGxCb3VuZHMiLCJzbmFwc0JvdW5kZWQiLCJtZWFzdXJlQm91bmRlZCIsInNjcm9sbENvbnRhaW5MaW1pdCIsImZpbmRTY3JvbGxDb250YWluTGltaXQiLCJzbmFwc0NvbnRhaW5lZCIsIm1lYXN1cmVDb250YWluZWQiLCJ1c2VQaXhlbFRvbGVyYW5jZSIsImJvdW5kIiwic25hcCIsInN0YXJ0U25hcCIsImVuZFNuYXAiLCJsYXN0SW5kZXhPZiIsInNuYXBBbGlnbmVkIiwiaXNGaXJzdCIsImlzTGFzdCIsInNjcm9sbEJvdW5kIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJzbGljZSIsIlNjcm9sbExpbWl0Iiwic2Nyb2xsU25hcHMiLCJTY3JvbGxMb29wZXIiLCJ2ZWN0b3JzIiwiam9pbnRTYWZldHkiLCJzaG91bGRMb29wIiwibG9vcERpc3RhbmNlIiwidiIsIlNjcm9sbFByb2dyZXNzIiwiU2Nyb2xsU25hcHMiLCJhbGlnbm1lbnQiLCJjb250YWluZXJSZWN0Iiwic2xpZGVSZWN0cyIsInNsaWRlc1RvU2Nyb2xsIiwiZ3JvdXBTbGlkZXMiLCJhbGlnbm1lbnRzIiwibWVhc3VyZVNpemVzIiwic25hcHMiLCJtZWFzdXJlVW5hbGlnbmVkIiwibWVhc3VyZUFsaWduZWQiLCJyZWN0cyIsInJlY3QiLCJnIiwiU2xpZGVSZWdpc3RyeSIsImNvbnRhaW5TbmFwcyIsInNsaWRlSW5kZXhlcyIsInNsaWRlUmVnaXN0cnkiLCJjcmVhdGVTbGlkZVJlZ2lzdHJ5IiwiZ3JvdXBlZFNsaWRlSW5kZXhlcyIsImRvTm90Q29udGFpbiIsImdyb3VwIiwiZ3JvdXBzIiwicmFuZ2UiLCJTY3JvbGxUYXJnZXQiLCJ0YXJnZXRWZWN0b3IiLCJtaW5EaXN0YW5jZSIsImRpc3RhbmNlcyIsInNvcnQiLCJhIiwiYiIsImZpbmRUYXJnZXRTbmFwIiwiYXNjRGlmZnNUb1NuYXBzIiwic2hvcnRjdXQiLCJkMSIsImQyIiwidGFyZ2V0cyIsIm1hdGNoaW5nVGFyZ2V0cyIsInQiLCJkaWZmVG9TbmFwIiwidGFyZ2V0U25hcERpc3RhbmNlIiwicmVhY2hlZEJvdW5kIiwic25hcERpc3RhbmNlIiwiU2Nyb2xsVG8iLCJpbmRleEN1cnJlbnQiLCJpbmRleFByZXZpb3VzIiwiZGlzdGFuY2VEaWZmIiwiaW5kZXhEaWZmIiwidGFyZ2V0SW5kZXgiLCJTbGlkZUZvY3VzIiwicm9vdCIsImV2ZW50U3RvcmUiLCJsYXN0VGFiUHJlc3NUaW1lIiwiZG9jdW1lbnQiLCJyZWdpc3RlclRhYlByZXNzIiwiYWRkU2xpZGVGb2N1c0V2ZW50IiwiZXZlbnQiLCJjb2RlIiwiRGF0ZSIsImdldFRpbWUiLCJzbGlkZSIsImZvY3VzIiwibm93VGltZSIsInNjcm9sbExlZnQiLCJmaW5kSW5kZXgiLCJjYXB0dXJlIiwiVmVjdG9yMUQiLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUlucHV0IiwiVHJhbnNsYXRlIiwidHJhbnNsYXRlIiwieCIsInkiLCJjb250YWluZXJTdHlsZSIsInN0eWxlIiwidG8iLCJ0cmFuc2Zvcm0iLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJTbGlkZUxvb3BlciIsInNsaWRlU2l6ZXNXaXRoR2FwcyIsInJvdW5kaW5nU2FmZXR5IiwiYXNjSXRlbXMiLCJkZXNjSXRlbXMiLCJyZXZlcnNlIiwibG9vcFBvaW50cyIsInN0YXJ0UG9pbnRzIiwiZW5kUG9pbnRzIiwicmVtb3ZlU2xpZGVTaXplcyIsImluZGV4ZXMiLCJzbGlkZXNJbkdhcCIsImdhcCIsInJlbWFpbmluZ0dhcCIsImZpbmRTbGlkZUJvdW5kcyIsImZpbmRMb29wUG9pbnRzIiwiaXNFbmRFZGdlIiwic2xpZGVCb3VuZHMiLCJpbml0aWFsIiwiYWx0ZXJlZCIsImJvdW5kRWRnZSIsImxvb3BQb2ludCIsInNsaWRlTG9jYXRpb24iLCJjYW5Mb29wIiwiZXZlcnkiLCJvdGhlckluZGV4ZXMiLCJzaGlmdExvY2F0aW9uIiwiU2xpZGVzSGFuZGxlciIsIndhdGNoU2xpZGVzIiwibXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dGF0aW9uIiwiTXV0YXRpb25PYnNlcnZlciIsImNoaWxkTGlzdCIsIlNsaWRlc0luVmlldyIsInRocmVzaG9sZCIsImludGVyc2VjdGlvbkVudHJ5TWFwIiwiaW5WaWV3Q2FjaGUiLCJub3RJblZpZXdDYWNoZSIsImludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJwYXJlbnRFbGVtZW50IiwiY3JlYXRlSW5WaWV3TGlzdCIsImluVmlldyIsImxpc3QiLCJwYXJzZUludCIsImlzSW50ZXJzZWN0aW5nIiwiaW5WaWV3TWF0Y2giLCJub3RJblZpZXdNYXRjaCIsIlNsaWRlU2l6ZXMiLCJyZWFkRWRnZUdhcCIsIndpdGhFZGdlR2FwIiwic3RhcnRHYXAiLCJtZWFzdXJlU3RhcnRHYXAiLCJlbmRHYXAiLCJtZWFzdXJlRW5kR2FwIiwibWVhc3VyZVdpdGhHYXBzIiwic2xpZGVSZWN0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJTbGlkZXNUb1Njcm9sbCIsImdyb3VwQnlOdW1iZXIiLCJieU51bWJlciIsImdyb3VwU2l6ZSIsImJ5U2l6ZSIsInJlY3RCIiwicmVjdEEiLCJlZGdlQSIsImVkZ2VCIiwiZ2FwQSIsImdhcEIiLCJjaHVua1NpemUiLCJjdXJyZW50U2l6ZSIsInByZXZpb3VzU2l6ZSIsIkVuZ2luZSIsInNjcm9sbEF4aXMiLCJzdGFydEluZGV4IiwiaW5WaWV3VGhyZXNob2xkIiwiZHJhZ0hhbmRsZXIiLCJzY3JvbGxMb29wZXIiLCJzbGlkZUxvb3BlciIsImhhc1NldHRsZWQiLCJlbmdpbmUiLCJzdGFydExvY2F0aW9uIiwic2Nyb2xsUHJvZ3Jlc3MiLCJzbGlkZXNJblZpZXciLCJzbGlkZUZvY3VzIiwicmVzaXplSGFuZGxlciIsInNjcm9sbFNuYXBMaXN0Iiwic2xpZGVzSGFuZGxlciIsIkV2ZW50SGFuZGxlciIsImFwaSIsImdldExpc3RlbmVycyIsImUiLCJvbiIsImNiIiwib2ZmIiwiZGVmYXVsdE9wdGlvbnMiLCJicmVha3BvaW50cyIsIk9wdGlvbnNIYW5kbGVyIiwibWVyZ2VPcHRpb25zIiwib3B0aW9uc0EiLCJvcHRpb25zQiIsIm9wdGlvbnNBdE1lZGlhIiwibWF0Y2hlZE1lZGlhT3B0aW9ucyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtZWRpYU9wdGlvbiIsIm9wdGlvbnNNZWRpYVF1ZXJpZXMiLCJvcHRpb25zTGlzdCIsImFjYyIsIm1lZGlhUXVlcmllcyIsIlBsdWdpbnNIYW5kbGVyIiwib3B0aW9uc0hhbmRsZXIiLCJhY3RpdmVQbHVnaW5zIiwicGx1Z2lucyIsInBsdWdpbiIsImFzc2lnbiIsIm5hbWUiLCJFbWJsYUNhcm91c2VsIiwidXNlck9wdGlvbnMiLCJ1c2VyUGx1Z2lucyIsImRlZmF1bHRWaWV3IiwicGx1Z2luc0hhbmRsZXIiLCJtZWRpYUhhbmRsZXJzIiwicmVBY3RpdmF0ZSIsIm9wdGlvbnNCYXNlIiwiZ2xvYmFsT3B0aW9ucyIsInBsdWdpbkxpc3QiLCJwbHVnaW5BcGlzIiwic3RvcmVFbGVtZW50cyIsInVzZXJDb250YWluZXIiLCJ1c2VyU2xpZGVzIiwiY3VzdG9tQ29udGFpbmVyIiwicXVlcnlTZWxlY3RvciIsImNoaWxkcmVuIiwiY3VzdG9tU2xpZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImNyZWF0ZUVuZ2luZSIsIm9wdGlvbnNXaXRob3V0TG9vcCIsImFjdGl2YXRlIiwid2l0aE9wdGlvbnMiLCJ3aXRoUGx1Z2lucyIsInF1ZXJ5Iiwib2Zmc2V0UGFyZW50Iiwic2VsZWN0ZWRTY3JvbGxTbmFwIiwiZGVBY3RpdmF0ZSIsImp1bXAiLCJzY3JvbGxOZXh0Iiwic2Nyb2xsUHJldiIsInByZXYiLCJjYW5TY3JvbGxOZXh0IiwiY2FuU2Nyb2xsUHJldiIsInByZXZpb3VzU2Nyb2xsU25hcCIsInNsaWRlc05vdEluVmlldyIsImludGVybmFsRW5naW5lIiwiY29udGFpbmVyTm9kZSIsInNsaWRlTm9kZXMiLCJzZXRUaW1lb3V0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;